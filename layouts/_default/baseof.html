<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode }}" dir="{{ default `ltr` .Language.LanguageDirection }}">
    <head>
        {{- partial "head/head.html" . -}}
        {{- block "head" . -}}{{ end }}
    </head>
    <body class="{{ block `body-class` . }}{{ end }}">
        {{- partial "head/colorScheme" . -}}

        {{/* The container is wider when there's any activated widget */}}
        {{- $hasWidget := false -}}
        {{- range .Site.Params.widgets -}}
            {{- if gt (len .) 0 -}}
                {{- $hasWidget = true -}}
            {{- end -}}
        {{- end -}}
        <div class="container main-container flex on-phone--column {{ if $hasWidget }}extended{{ else }}compact{{ end }}">
            {{- block "left-sidebar" . -}}
                {{ partial "sidebar/left.html" . }}
            {{- end -}}
            {{- block "right-sidebar" . -}}{{ end }}
            <main class="main full-width">
                {{- block "main" . }}{{- end }}
            </main>
        </div>
        {{ partial "footer/include.html" . }}
        <script>
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+";
  const texts = [
    "Добро пожаловать!",
    "Это мой блог о вебе.",
    "JavaScript — это магия.",
    "Больше, чем просто код.",
    "Просто мысли вслух."
  ];

  const ENCRYPT_SPEED = 50;     // скорость шифровки (меньше = быстрее)
  const DECRYPT_SPEED = 50;     // скорость расшифровки
  const GLITCH_COUNT = 3;       // сколько раз «глючит» каждый символ
  const PAUSE_BETWEEN = 15000;  // пауза между циклами (в мс)

  function randomChar() {
    return letters[Math.floor(Math.random() * letters.length)];
  }

  function padToLength(str, length) {
    return str.padEnd(length, " ");
  }

  // Зашумление одного символа
  function glitchChar(el, chars, index) {
    return new Promise((resolve) => {
      let count = 0;
      const interval = setInterval(() => {
        chars[index] = randomChar();
        el.innerText = chars.join("");
        count++;
        if (count >= GLITCH_COUNT) {
          clearInterval(interval);
          chars[index] = randomChar(); // финальный глюк
          el.innerText = chars.join("");
          resolve();
        }
      }, ENCRYPT_SPEED);
    });
  }

  // Расшифровка одного символа
  function decryptChar(el, chars, final, index) {
    return new Promise((resolve) => {
      let count = 0;
      const interval = setInterval(() => {
        chars[index] = randomChar();
        el.innerText = chars.join("");
        count++;
        if (count >= GLITCH_COUNT) {
          clearInterval(interval);
          chars[index] = final[index];
          el.innerText = chars.join("");
          resolve();
        }
      }, DECRYPT_SPEED);
    });
  }

  // Шифруем строку
  async function stepEncrypt(el, length) {
    const chars = el.innerText.split("");
    for (let i = 0; i < length; i++) {
      await glitchChar(el, chars, i);
    }
  }

  // Расшифровываем строку с удалением лишних символов
async function stepDecrypt(el, finalText) {
  let chars = el.innerText.split("");
  const targetLength = finalText.length;

  // Расшифровываем только нужное количество символов
  for (let i = 0; i < targetLength; i++) {
    await decryptChar(el, chars, finalText, i);
  }

  // Удаляем лишние символы сразу, без анимации
  chars = chars.slice(0, targetLength);
  el.innerText = chars.join("");
}



  // Основная анимация для одного элемента
  async function animateElement(el, newText) {
    const oldText = el.innerText;
    const maxLen = Math.max(oldText.length, newText.length);
    const paddedOld = padToLength(oldText, maxLen);
    const paddedNew = padToLength(newText, maxLen);

    el.innerText = paddedOld;

    await stepEncrypt(el, paddedOld.length);
    await stepDecrypt(el, paddedNew);

    // Гарантируем финальную очистку от пробелов
    el.innerText = newText;
  }

  // Цикл для всех .site-description
  async function startCycle() {
    const elements = document.querySelectorAll(".site-description");

    while (true) {
      for (const el of elements) {
        const newText = texts[Math.floor(Math.random() * texts.length)];
        await animateElement(el, newText);
      }

      await new Promise((res) => setTimeout(res, PAUSE_BETWEEN));
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    startCycle();
  });
</script>




    </body>
</html>