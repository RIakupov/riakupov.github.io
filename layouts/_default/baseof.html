<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode }}" dir="{{ default `ltr` .Language.LanguageDirection }}">
    <head>
        {{- partial "head/head.html" . -}}
        {{- block "head" . -}}{{ end }}
    </head>
    <body class="{{ block `body-class` . }}{{ end }}">
        {{- partial "head/colorScheme" . -}}

        {{/* The container is wider when there's any activated widget */}}
        {{- $hasWidget := false -}}
        {{- range .Site.Params.widgets -}}
            {{- if gt (len .) 0 -}}
                {{- $hasWidget = true -}}
            {{- end -}}
        {{- end -}}
        <div class="container main-container flex on-phone--column {{ if $hasWidget }}extended{{ else }}compact{{ end }}">
            {{- block "left-sidebar" . -}}
                {{ partial "sidebar/left.html" . }}
            {{- end -}}
            {{- block "right-sidebar" . -}}{{ end }}
            <main class="main full-width">
                {{- block "main" . }}{{- end }}
            </main>
        </div>
        {{ partial "footer/include.html" . }}
        <script>
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+";
  const texts = [
    "Добро пожаловать!",
    "Это мой блог о вебе.",
    "JavaScript — это магия.",
    "Больше, чем просто код.",
    "Просто мысли вслух."
  ];

  // Возвращает случайный символ из letters
  function randomChar() {
    return letters[Math.floor(Math.random() * letters.length)];
  }

  // Шифрует текст посимвольно
  function encryptText(current, targetLength) {
    const maxLen = Math.max(current.length, targetLength);
    return Array.from({ length: maxLen }, (_, i) =>
      i < current.length ? randomChar() : randomChar()
    ).join("");
  }

  // Расшифровывает по буквам
  function decryptTextStep(current, target, progress) {
    return target
      .split("")
      .map((char, i) => (i < progress ? char : randomChar()))
      .join("");
  }

  function animateTransition(element, newText) {
    const oldText = element.innerText;
    let encrypted = oldText;
    let step = 0;
    const maxLen = Math.max(oldText.length, newText.length);

    // 1. Шифруем старый текст
    const encryptInterval = setInterval(() => {
      encrypted = encryptText(encrypted, newText.length);
      element.innerText = encrypted;
      step++;
      if (step > 10) {
        clearInterval(encryptInterval);

        // 2. Плавно расшифровываем на новый текст
        let progress = 0;
        const decryptInterval = setInterval(() => {
          element.innerText = decryptTextStep(encrypted, newText, progress);
          progress++;
          if (progress > newText.length) {
            clearInterval(decryptInterval);
          }
        }, 50);
      }
    }, 50);
  }

  function updateDescriptions() {
    const elements = document.querySelectorAll(".site-description");
    elements.forEach((el) => {
      const newText = texts[Math.floor(Math.random() * texts.length)];
      animateTransition(el, newText);
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    // Первый запуск
    setTimeout(updateDescriptions, 1000);

    // Повторяем каждые 30 секунд
    setInterval(updateDescriptions, 30000);
  });
</script>

    </body>
</html>