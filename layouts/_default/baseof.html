<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode }}" dir="{{ default `ltr` .Language.LanguageDirection }}">
    <head>
        {{- partial "head/head.html" . -}}
        {{- block "head" . -}}{{ end }}
    </head>
    <body class="{{ block `body-class` . }}{{ end }}">
        {{- partial "head/colorScheme" . -}}

        {{/* The container is wider when there's any activated widget */}}
        {{- $hasWidget := false -}}
        {{- range .Site.Params.widgets -}}
            {{- if gt (len .) 0 -}}
                {{- $hasWidget = true -}}
            {{- end -}}
        {{- end -}}
        <div class="container main-container flex on-phone--column {{ if $hasWidget }}extended{{ else }}compact{{ end }}">
            {{- block "left-sidebar" . -}}
                {{ partial "sidebar/left.html" . }}
            {{- end -}}
            {{- block "right-sidebar" . -}}{{ end }}
            <main class="main full-width">
                {{- block "main" . }}{{- end }}
            </main>
        </div>
        {{ partial "footer/include.html" . }}
        <script>
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+";
  const texts = [
    "Добро пожаловать!",
    "Это мой блог о вебе.",
    "JavaScript — это магия.",
    "Больше, чем просто код.",
    "Просто мысли вслух."
  ];

  const ENCRYPT_SPEED = 50;     // скорость посимвольной шифровки (меньше — быстрее)
  const DECRYPT_SPEED = 50;     // скорость посимвольной расшифровки
  const GLITCH_COUNT = 3;       // сколько раз символ "глючит" перед фиксацией
  const PAUSE_BETWEEN = 15000;  // пауза между циклами (в мс)

  function randomChar() {
    return letters[Math.floor(Math.random() * letters.length)];
  }

  function padToLength(str, length) {
    return str.padEnd(length, " ");
  }

  // Шифровка одного символа с глюками
  function glitchChar(el, chars, index) {
    return new Promise((resolve) => {
      let count = 0;
      const interval = setInterval(() => {
        chars[index] = randomChar();
        el.innerText = chars.join("");
        count++;
        if (count >= GLITCH_COUNT) {
          clearInterval(interval);
          chars[index] = randomChar(); // финальный зашифрованный символ
          el.innerText = chars.join("");
          resolve();
        }
      }, ENCRYPT_SPEED);
    });
  }

  // Расшифровка одного символа
  function decryptChar(el, chars, final, index) {
    return new Promise((resolve) => {
      let count = 0;
      const interval = setInterval(() => {
        chars[index] = randomChar();
        el.innerText = chars.join("");
        count++;
        if (count >= GLITCH_COUNT) {
          clearInterval(interval);
          chars[index] = final[index];
          el.innerText = chars.join("");
          resolve();
        }
      }, DECRYPT_SPEED);
    });
  }

  // Шифровка всей строки по очереди
  async function stepEncrypt(el, textLength) {
    const chars = el.innerText.split("");
    for (let i = 0; i < textLength; i++) {
      await glitchChar(el, chars, i);
    }
  }

  // Расшифровка всей строки по очереди
  async function stepDecrypt(el, finalText) {
    const chars = el.innerText.split("");
    for (let i = 0; i < finalText.length; i++) {
      await decryptChar(el, chars, finalText, i);
    }

    // Удаление лишних символов, если финальный текст короче
    if (chars.length > finalText.length) {
      chars.length = finalText.length;
      el.innerText = chars.join("");
    }
  }

  // Главная функция анимации
  async function animateElement(el, newText) {
    const oldText = el.innerText;
    const maxLen = Math.max(oldText.length, newText.length);
    const paddedOld = padToLength(oldText, maxLen);
    const paddedNew = padToLength(newText, maxLen);

    el.innerText = paddedOld;

    await stepEncrypt(el, paddedOld.length);
    await stepDecrypt(el, paddedNew);
  }

  async function startCycle() {
    const elements = document.querySelectorAll(".site-description");

    while (true) {
      for (const el of elements) {
        const newText = texts[Math.floor(Math.random() * texts.length)];
        await animateElement(el, newText);
      }

      await new Promise((res) => setTimeout(res, PAUSE_BETWEEN));
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    startCycle();
  });
</script>



    </body>
</html>